/*
 * Copyright (c) Ward6 July 2011.
 * Ward6 EDetailerPage API for JavaScript/Object-C data communication and
 * Reference tooltips.
 *
 * @author Kashi Samaraweera
 * @version 2.2.9
 * @since May 31st, 2012
 */

String.prototype.trim=function(){a=this.replace(/^\s+/,'');return a.replace(/\s+$/,'');};

/*
 * Establish our namespacing
 */

var com = com || {};
com.ward6 = com.ward6 || {};

/**
 * The EDetailerPage module manages the data input/output for an individual
 * detailer content page used in Ward6 eDetailers. It is a relatively small API
 * for interfacing with the native application which encapsulates the module 
 * pages.
 * 
 * The API is used by both the JavaScript occurring on the edetailer pages and
 * the edetailer's built-in navigator object using Object-C.
 * 
 * @module EDetailerPage
 */

/**
 * The EDetailerPage object references the targeted page and has a series of
 * methods that can send/receive information to and from the page. It is
 * instantiated automatically and exists in the global scope.
 * 
 * @global
 * @static
 * @class EDetailerPage
 */
com.ward6.EDetailerPage = (function() {
    
    /*
     * Constants
     */
    
    /**
     * _DEBUG_MODE is a global flag that can be used to show or suppress console
     * logs.
     */
    /**
     * The _PROFILES object holds profile data in an Array. Each profile is
     * saved as a string which will determine and assign the appropriate CSS
     * class for the sidebar UL element.
     * 
     * @property _PROFILES
     */
    /**
     * _PERSISTENT_PAGES holds the pageIds of each page that should have its
     * data saved between calls to EDetailerPage.clearSessionData(). These are
     * arranged in a standard JavaScript Array.
     * 
     * @param _PERSISTENT_PAGES {String[]} holds a list of pageIds that will
     *        have their pageData stored between calls to clearSessionData.
     */
    /**
     * _EDETAILER_NAME is a prefix added to all keys that are set and retrieved
     * from the localStorage. This is used to prevent conflicts between Ward6
     * eDetailer productions.
     * This MUST be changed for each project undertaken, usually following the
     * convention:
     *
     *      com_ward6_<projectname>
     *
     * localStorage data will have keys such as "com_ward6_<projectname>_<key>"
     * to store their data when methods setPageData and getPageData are used.
     */
    /**
     * _ACTIVATE_ONLY_ONCE is a boolean value that determines whether pages are
     * allowed to be activated once (after each load), or if they may be
     * activated numerous times. This is generally determined by the eDetailer
     * as some will require intra-page adjustments for each activation, and some
     * need an uninterrupted runtime after their premiere activation.
     */
    var _DEBUG_MODE = false,
        _PROFILES = ['default'],
        _PERSISTENT_PAGES = [],
        _ACTIVATE_ONLY_ONCE = false,
        _EDETAILER_NAME = 'com_ward6_eviplera';
        
    /*
     * Member variables
     */
    /**
     * The EDetailerAPI holds the publicly-available methods for the
     * EDetailerPage object. It will be manipulated using the EDetailerPage
     * object.
     * @private
     * @property EDetailerAPI
     * @type EDetailerAPI
     * @type Function
     */
     /**
     * _pageInfo is a private member property that holds all the information
     * specific to the current page. Use get/set Data/PageId object.
     * @property _pageInfo
     * @private
     * @type PageInfoObject
     */
    var EDetailerAPI = {
            isApp : /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent),
            UIEvents      : {
                DOWN            : ('ontouchstart' in document.documentElement)? 'touchstart' : 'mousedown',
                MOVE            : ('ontouchmove' in document.documentElement)? 'touchmove' : 'mousemove',
                UP              : ('ontouchend' in document.documentElement)? 'touchend' : 'mouseup',
                CLICK           : "click"
            },
            DEBUG_MODE  : _DEBUG_MODE
        },
        _pageInfo = {
            id : undefined,
            data : undefined,
            dataPersistent : undefined,
            enableProfile : true,
            activated : false,
            activateFunctions : Array(),
            deactivateFunctions : Array()
        },
        _xmlReferencesDocument = false;
    
    /*
     * Member functions
     */
    
    /**
     * JavaScript API<br />
     * This method stores the page's unique id.
     * @method setPageId
     * @static
     * @param {String} newPageId The unique page id for this page.
     * @return {Boolean} Returns true if the page id was supplied in the expected data
     *         type, false if it was not (and thus not stored).
     */
    EDetailerAPI.setPageId = function(newPageId) {
        if (typeof(newPageId) === "string" && (newPageId.length > 0)) {
            _pageInfo.id = newPageId;
            return true;
        }
        return false;
    };
    
    /**
     * JavaScript API<br />
     * This method fetches the unique id for the page.
     * @method getPageId
     * @static
     * @return {String} The unique page id for this page.
     */
    EDetailerAPI.getPageId = function() {
        if (_pageInfo.id.length > 0) {
            return _pageInfo.id;
        }
        return false;
    };
    
    /**
     * JavaScript API<br />
     * This method set's the module for the page (which fetches the references
     * information). The XML document specified should follow the references DTD
     * document contained in the resources section of this project.
     * Loading the XML document is a time-intensive exercise so it will be added
     * to the queue for the Window.onload event.
     * @method setModuleXML
     * @param {String} xmlFilename The relative path to the XML file to load for
     *        references.
     * @static
     * @return {Boolean} returns true if the file was found for the specified
     *         module, false if the XML file could not be found.
     */
    EDetailerAPI.setModuleXML = function(xmlFilename) {
        if (typeof($) === "undefined") {
            console.warn("jQuery not found in global '$'");
            return false;
        }
        _xmlReferencesDocument = xmlFilename;
        $(window).bind(
            'load',
            { _this : this },
            _downloadXML
        );
    };
    
    /**
     * Downloads the XML file that has been specified after the page has
     * finished loading. Upon completion, the references are parsed by the
     * processXML method of the API.
     * @method _downloadXML
     * @param {jqEvent} The jQuery event object for window.load.
     * @static
     * @private
     */
    function _downloadXML(windowLoadEvent) {
        var _this = windowLoadEvent.data._this;
        if (!_xmlReferencesDocument)
            return false;

        $.ajax({
            url : _xmlReferencesDocument,
            error : function () {
                console.warn("The XML file for references was not found in: " + _xmlReferencesDocument + "\nPlease check the path supplied and try again.");
            },
            dataType: "xml",
            isLocal : true,
            timeout : 1000,
            success : _this.processXML,
            context : _this
        });
    }
    
    EDetailerAPI.processXML = function(data, textStatus, jqXHR) {
        this.References.storeModuleReferences(data);
    };
    
    /**
     * This method saves the data for the current page. It will save the data
     * supplied in two locations: <ul><li>A local (private) JavaScript 
     * variable</li><li>The browser's native localStorage object.</li></ul>
     * value with the new object.
     *
     * Persistent data can be added by setting the second optional argument to
     * true when calling the method. Persistent data will be preserved after
     * calling the clearSessionData method.
     * @method setPageData
     * @static
     * @param {String} dataToSave The data to be stored. This value may also be
     *        an <code property="yui:name">object</code>. All other data types
     *        are rejected (including primitives).
     * @param {Boolean} isPersistent is an optional arugment to set the data
     *        being saved to persistent, making it survive calls to the 
     *        EDetailerpage.clearSessionData() method.
     * @return {Boolean} Returns true if the data supplied was in the expected
     *         data type, false if it was not (and thus not stored). It will
     *         also return false upon failing access a localStorage object.
     */
    EDetailerAPI.setPageData = function(dataToSave, isPersistent) {
        var pageKey = _EDETAILER_NAME + '_' + _pageInfo.id;
        if (typeof(isPersistent) === "undefined")
            isPersistent = false;

        if (isPersistent)
            pageKey += '_persistent';

        if (typeof(dataToSave) === "string" || typeof(dataToSave) === "object") {
            
            if (isPersistent)
                _pageInfo.persistentData = dataToSave;
            else
                _pageInfo.data = dataToSave;

            try {
                var jsonData = JSON.stringify(dataToSave);
            } catch (e) {
                if (typeof(e.message) === "string") {
                    throw new Error("Error with JSON: " + e.message);
                }
                throw new Error("Error with JSON. No error message provided.");
            }

            // Time to save it globally.
            if (typeof(_pageInfo.id) === "undefined") {
                throw new Error("The page has no ID set.");
            }

            try {
                localStorage.setItem(pageKey, jsonData);
            } catch (e) {
                if (typeof(e.message) === "string") {
                    throw new Error("Error with localStorage: " + e.message);
                }
                throw new Error("Error with localStorage. No error message provided.");
            }
            return true;
        }
        return false;
    };

    /**
     * This method will clear the data saved to the browser's localStorage
     * object that has been stored using this application.
     * 
     * Objects that are saved as persistent (either by being a member of the
     * _PERSISTENT_PAGES array or submitting the persistent argument when
     * calling setPageData.
     *
     * Previous versions of this method called localStorage.clear(), which
     * removed all key/value pairs from the same host. Seeing as it's likely
     * that more than one iPad will hold multiple EDetailerPage-driven detailers
     * it has been re-written to be less destructive.
     *
     * @method clearSessionData
     */

    EDetailerAPI.clearSessionData = function() {
    	var storedItems = localStorage.length;
    	
    	for (item in localStorage) {
    	   if (new RegExp('^(' + _EDETAILER_NAME + ')', 'i').test(item)) {
                // This entry belongs to this eDetailer. Check for persistence.
                if (/(_persistent)$/i.test(item))
                    continue;

                // Scan through our list of persistent pages, continue if it's listed.
                for (persistentItems in _PERSISTENT_PAGES)
                    if (item === _PERSISTENT_PAGES[persistentItems])
                        continue;

                if (_DEBUG_MODE) console.log("Removing item '" + item + '" from localStorage.');
                localStorage.removeItem(item);
    	   }
    	} 
        return true;
    };

    /**
     * This object retreives page data. If there is no argument supplied it will
     * return the local (private) JavaScript variable which holds the page data.
     * If an argument pageId is supplied and data exists for the given pageId
     * the data stored for that page is returned instead.
     *
     * This method will automatically fetch both persistent and temporary
     * (session) data. If there is only one of these available, that one will
     * be returned, otherwise they will be combined into one object and any
     * objects belonging to the temporary data with the same name as that in the
     * persistent data will be overwritten.
     * @method getPageData
     * @static
     * @param {String} pageId [Optional] If the pageId argument is supplied, the
     *        method searches the browser's built-in localStorage object for
     *        data stored to that page.
     * @return {Object} Returns the data stored as a standard JavaScript object.
     *         If no data has been stored for either the current page or the
     *         page defined as pageId (see parameters) a Boolean value of false
     *         is returned.
     */
    EDetailerAPI.getPageData = function(pageId) {
        var pageKey = false,
            temporaryPageData = false,
            persistentPageData = false,
            pageData = {};
            
        // Test the argument to see if it's this page we're asking for.
        if (typeof(pageId) === "undefined") {
            if (typeof(_pageInfo.id) === "string") {
                pageId = _pageInfo.id;
            } else {
                // Combine the temporary and persistent data.
                if (typeof(_pageInfo.data) === "object")
                    for (i in _pageInfo.data)
                        pageData[i] = _pageInfo.data[i];

                if (typeof(_pageInfo.dataPersistent) === "object")
                    for (i in _pageInfo.dataPersistent)
                        pageData[i] = _pageInfo.dataPersistent[i];
                        
                return pageData;
            }
        }
        
        // Set our pageKey
        pageKey = _EDETAILER_NAME + '_' + pageId;
        
        try {
            var requestedPageData = localStorage.getItem(pageKey),
                requestedPageDataPersistent = localStorage.getItem(pageKey + '_persistent');
        } catch (e) {
           if (typeof(e.message) === "string") {
                throw new Error("Error with localStorage: " + e.message);
            }
            throw new Error("Error with localStorage. No error message provided.");
        }
        
        if (typeof(requestedPageData) === 'string') {
            try {
                temporaryPageData = JSON.parse(requestedPageData) || false;
            } catch (e) {
                if (typeof(e.message) === "string")
                    throw new Error("Error with JSON: " + e.message);
                persistentPage = false;
            }
            if (typeof(temporaryPageData) === "object")
                for (i in temporaryPageData)
                    pageData[i] = temporaryPageData[i];
        }

        // Add the persistent data.
        if (typeof(requestedPageDataPersistent) === 'string') {
            try {
                persistentPageData = JSON.parse(requestedPageDataPersistent);
            } catch (e) {
                if (typeof(e.message) === "string")
                    throw new Error("Error with JSON: " + e.message);
                persistentPageData = false;
            }

            if (typeof(persistentPageData) === "object")
                for (i in persistentPageData)
                    pageData[i] = persistentPageData[i];
        }
        
        return (Object.keys(pageData).length)? pageData : false;
    };

    /**
     * This method can be called to set profile switching for this page. This
     * will modify the internal _pageInfo.enableProfile boolean variable with
     * the value provided as profileEnabled.
     * @method setProfileEnabled
     * @param profileEnabled
     */
    EDetailerAPI.setProfileEnabled = function(profileEnabled) {
        var profileEnabled = (typeof(profileEnabled) === "boolean")? profileEnabled : _pageInfo.enableProfile;
        _pageInfo.enableProfile = profileEnabled;
    };

    /**
     * The setProfile method will configure the page for a profile. Profile
     * details are stored in the EDetailerPage class definition, and the
     * supplied profileNumber will target a specific profile.
     * @method setProfile
     * @param {Number} profileNumber the number of the profile to load (as 
     *        stored in the EDetailerPage class.
     * @param {Boolean} reset (optional) clears the localStorage cache and all
     *        pageData stored by the EDetailerPage object.
     */
    EDetailerAPI.setProfile = function(profileNumber) {
        var sidebar = $('#container'),
            profileData = $('.profileData'),
            profileEnabled = _pageInfo.enableProfile;

        if (!profileEnabled) {
            return false;
        }
        if (typeof(profileNumber) !== "number") {
            return false;
        }

        if ($('.sidebar').length <= 1) {
            return false;
        }

        if (profileNumber < _PROFILES.length) {
            var classToAdd = _PROFILES[profileNumber];

            var profileCounter = _PROFILES.length;
            while (profileCounter--) {
                var currentProfile = $("li." + _PROFILES[profileCounter] + "Sidebar");
                if (profileCounter !== profileNumber) {
                    currentProfile.hide();
                } else {
                    currentProfile.show();
                }
            }

            sidebar.removeClass();
            sidebar.addClass(classToAdd);
            localStorage.activeProfile = profileNumber;
        }

        return true;
    }
    
    /**
     * Native App API<br /><br />
     * This is the primary activation function for the page (to be called by the navigator).
     * It takes two arguments which will hold the page's unique ID and it's stored data.
     * This method also executes all the stored JavaScript functions that are held
     * in the activateFunctions queue, the page. This is the only call that will be required
     * to activate the page.
     *
     * This method will short-circuit if the _ACTIVATE_ONLY_ONCE private constant is set to
     * true and the page has already been activated.
     * @method activate
     * @static
     * @param {String} jsonData [optional] The data stored for this page in JSON
     *        notation.  Please note that may be left undefined if the setPageData 
     *        method has already been called.
     * @return {Boolean} returns true if the procedure executed successfully, or
     *         false if any stored methods had an exit code other than true.
     */
    EDetailerAPI.activate = function() {
        if (_ACTIVATE_ONLY_ONCE && _pageInfo.activated)
            return false;

        _pageInfo.activated = true;
        var functionList = _pageInfo.activateFunctions;
        $(document).trigger('click');
        return _runFunctions(functionList);
    };
    
    /**
     * Native App API<br /><br />
     * Executes all the stored JavaScript functions that must fire on deactivating
     * the page. This is the only call that will be required to deactivate the page.
     * @method deactivate
     * @static
     * @return {String} returns the data for the current page in JSON notation.
     */
    EDetailerAPI.deactivate = function()  {
        var functionList = _pageInfo.deactivateFunctions;
        return _runFunctions(functionList);;
    };
    
    /**
     * Executes all stored JavaScript functions for a given function list. Used by
     * both the activate and deactivate methods.
     * @method _runFunctions
     * @private
     * @static
     * @param {FunctionList[]} functionList An array of functions and their associated
     *        arguments to be called.
     * @return {Boolean} returns true if all functions executed with a return code of
     *         true, false otherwise.
     */
    function _runFunctions(functionList) {
        var fNumber = functionList.length,
            called = true;

        while (fNumber--) {
            var funcObj = functionList[fNumber],
                functionRef = undefined,
                args = undefined,
                functionContext = this,
                argLength = 0;

            functionRef = funcObj.func;
            args = funcObj.arg;
            if (typeof(funcObj.suppliedContext) !== "undefined") {
                functionContext = funcObj.suppliedContext;
            }

            functionRef.apply(functionContext, args);
        }

        return called;
    };
    
    /**
     * Adds a function to be added to the activation queue to be fired once the
     * page is marked as active. Functions must be supplied as a reference. Arguments
     * are optional, and manipulate the function call in the same order in which
     * they're provided.
     * <br /><br />Note: Functions provided will have their scope set to within the EDetailerPage
     * object.
     * @method addActivateFunction
     * @static
     * @param {Function} functionRef The function that will be called. This must be
     *        a variable of type Function.
     * @param {*} arg0,arg1,arg2...,argN [optional] Arguments are passed in the order 
     *            they should modify the function. eg. functionRef(arg0, arg1, ... argN);
     * @return {Boolean} returns true if the procedure executed successfully, or
     *         false if any stored methods had an exit code other than 0.
     */
    EDetailerAPI.addActivateFunction = function() {
        return _addToFunctionQueue(_pageInfo.activateFunctions, arguments);
    };
       
    /**
     * Adds a function to be added to the deactivation queue to be fired once the
     * page is marked as inactive. Functions must be supplied as a reference. Arguments
     * are optional, and manipulate the function call in the same order in which
     * they're provided.
     * <br /><br />Note: Functions provided will have their scope set to within the EDetailerPage
     * object.
     * @method addDeactivateFunction
     * @static
     * @param {Function} functionRef The function that will be called. This must be
     *        a variable of type Function.
     * @param {*} arg0,arg1,arg2...,argN [optional] Arguments are passed in the order 
     *            they should modify the function. eg. functionRef(arg0, arg1, ... argN);
     * @return {Boolean} returns true if the procedure executed successfully, or
     *         false if any stored methods had an exit code other than 0.
     */
    EDetailerAPI.addDeactivateFunction = function() {
        return _addToFunctionQueue(_pageInfo.deactivateFunctions, arguments);
    };
    
    /**
     * Adds a new function reference and it's supplied arguments to the function queue
     * specified. This is an internal method which is used by addActivateFunction and
     * addDeactivateFunction.
     * @method _addToFunctionQueue
     * @private
     * @param {FunctionList[]} functionList a reference to the private function list
     *        array which holds a list of functions to be fired upon an event trigger.
     * @param {Function} functionRef A reference to the function which needs to be added
     *        to the function queue.
     * @param {*} arg0,arg1,arg2...,argN [optional] Arguments are passed in the order 
     *            they should modify the function. eg. functionRef(arg0, arg1, ... argN);
     */
    function _addToFunctionQueue() {
        var functionList = Array.prototype.shift.call(arguments),
            funcObj = Array.prototype.shift.call(arguments),
            arrayLength = 0,
            newCall = {};

        newCall.func = Array.prototype.shift.call(funcObj);
        if (funcObj.length > 0 && (typeof(funcObj[0].context) !== "undefined")) {
            newCall.suppliedContext = Array.prototype.shift.call(funcObj).context;
        }
        newCall.arg = funcObj;
        arrayLength = functionList.length;
        return (arrayLength < functionList.push(newCall));
    }
    
    // Begin References
    /**
     * The References class handles all the tooltips for the page. These tooltips will be
     * handled automatically, simply calling the addReference method will automatically instantiate
     * a tooltip.
     * @class EDetailerPage.References
     * @static
     */
    EDetailerAPI.References = (function() {
        /**
         * The ReferencesAPI holds all the publically-available commands. These will be mapped
         * directly to the References object.
         * @property {ReferenceAPI} ReferencesAPI
         * @private
         * @static
         */
        /**
         * The _referenceList property holds all the reference information for the page. This
         * is intialised as an empty array and must be manipulated by the addReference method.
         * @property {Reference[]} _referenceList
         * @private
         * @static
         */
        /**
         * _supTags stores all the &lt;sup&gt; tags on the page as a collection of jQuery objects.
         * This exists as a local (private) property in the References namespace as searching the
         * DOM for SUP tags is an expensive operation and should only be done once.
         * @property {jQuery[]} _supTags
         * @private
         * @static
         */
        /**
         * The _pageBound property keeps track of whether a method has been attached to the
         * document's click handler to clear all active tooltips.
         * @property {Boolean} _pageBound
         * @private
         * @default false
         * @static
         */
        /**
         * The _moduleReferences property is used to hold each of the references for the module
         * that are loaded by an XML file using the EDetailerPage API. They will automatically
         * be populated by successfully loading an XML file.
         * @property {ModuleReference[]} _moduleReferences
         * @private
         * @static
         */
        var ReferencesAPI = {},
            _referenceList = Array(),
            _supTags,
            _pageBound = false,
            _moduleReferences = Array();
        
        /**
         * The storeModuleReferences method will parse a set of references (as XML) and store
         * the contained information as objects for use in memory. These objects are stored in
         * the private _moduleReferences array.
         * @method storeModuleReferences
         * @param {String} moduleReferencesXML A string containing the references for the entire
         *        module as an XML file (defined by references.dtd).
         * @return {Boolean} returns true if parsed successfully, false otherwise.
         */
        ReferencesAPI.storeModuleReferences = function(moduleReferencesXML) {
            var _this = this;
            if (typeof $ === "undefined") {
                console.warn("No jQuery found!");
                return false;
            }
            
            if (jQuery.isXMLDoc(moduleReferencesXML)) {
                var referencesXML = $(moduleReferencesXML).find('reference');
                referencesXML.each(
                    function (refIndex, reference) {
                        var reference = $(reference),
                            refNumber = reference.find('number').text(),
                            refText = reference.find('note').text(),
                            refDocument = reference.find('document').text();
                        
                        // If there's a relevant document, encapsulate the reference in a link
                        if (refDocument !== "")
                            refText = '<a href="app://popup//' + refDocument.replace(/http\:\/\//gi, '') + '">' + refText + '</a>';
                        
                        if (parseInt(refNumber) > 0 && (refText.length > 0)) {
                            _moduleReferences.push({ number : refNumber, note : refText });
                        }
                    }
                );
                // Now that we have the references that apply to the module, we'll start matching
                // the contents of <sup> tags to their references.
                
                if (_supTags === undefined) {
                    _supTags = $('sup:not(.noTooltip)');
                }
                
                _supTags.each(
                    function (supIndex, thisSupTag) {
                        var supTag = $(thisSupTag);
                            supTagContents = supTag.attr('rel'),
                            supTagRefs = _parseReferences(supTagContents),
                            isInPopup = supTag.parents('div.popup').length !== 0,
                            isInHeading = supTag.parents('div.headerPanel').length !== 0;
                            
                        if (supTagRefs) {
                            var refCounter = supTagRefs.length,
                                refHeader = (refCounter === 1)? '<h6>Reference</h6>' : '<h6>References</h6>',
                                refHTML = refHeader + "\n" + '<table class="referenceTooltip">',
                                totalCodes = 0;
                            
                            while (refCounter--) {
                                // Find the appropriate reference.
                                var refCode = supTagRefs[refCounter],
                                    refNote = _this.fetchStoredReference(refCode);
                                
                                if (refNote) {
                                    //refHTML += '<h5>' + refCode + ': </h5><p>' + refNote + '</p>';
                                    refHTML += '<tr><td><p>' + refNote + '</p></td>';
                                    totalCodes++;
                                }
                            }
                            
                            if (isInPopup && !isInHeading)
                                supTag.addClass('forceTipTop');
                            if (isInHeading)
                                supTag.addClass('forceTipLeft');

                            refHTML += '</table>';
                            if (totalCodes > 0) {
                                _this.addReference(
                                    { trigger : supTag,
                                      description: refHTML }
                                );
                            }
                        } // End if (supTagRefs)
                    }
                );
                if (!_pageBound) {
                    _bind();
                    _pageBound = true;
                }
                return true;
            }
            return false;
        };
        
        /**
         * The fetchStoredReference method will comb through the stored references (this assumes that
         * storeModuleReferences has been called so that the references XML file for this module has
         * been commited to memory) to find one matching to the given argument <code>referenceCode</code>
         * @method fetchStoredReference
         * @param {String} referenceCode the single reference number (or code, in the case of symbols)
         *        to recognise. If this code is matched, a definition is returned.
         * @return {String} the definition of the code if a match is found. If no match is found, a
         *         <code>Boolean</code> value of <code>false</code> is returned instead.
         */

        ReferencesAPI.fetchStoredReference = function(referenceCode) {
            var refCounter = _moduleReferences.length;
            if (refCounter > 0) {
                while(refCounter--) {
                    if (String(_moduleReferences[refCounter].number) === String(referenceCode))
                        return _moduleReferences[refCounter].note;
                    if (parseInt(_moduleReferences[refCounter].number) === parseInt(referenceCode) && !isNaN(parseInt(referenceCode)))
                        return _moduleReferences[refCounter].note;
                }
            }
            return false;
        }
        
        /**
         * The _parseReferences function will comb through each of the page's &lt;sup&gt; tags
         * looking for patterns that identify reference numbers. References must be recognised as
         * in variety of formats from single digits (eg. 6) to comma seperated digits (eg. 4,5,9)
         * and ranges (eg. 12-25). This is the helper function which reads these reference queues
         * and collates the relevant reference information from the stored XML file.
         * @method _parseReferences
         * @private
         * @param {String} refsString the string of characters to parse for reference numbers
         * @return {Number[]} returns an array of the reference numbers encountered, expanded to
         *         identify ranges as individial numbers.
         */
        function _parseReferences(refsString) {
            // NLP time (info tech., not psychology)...
            if (refsString === undefined) return false;
            var refsString = refsString.replace(/[^0-9,–-]/gi, '').replace(/–/g, '-'),
                individualRef = refsString.split(','),
                refNo = individualRef.length,
                containedReferences = Array();

            while (refNo--) {
                var thisRef = individualRef[refNo].trim();
                if (thisRef.indexOf('-') > 0) { // Signifies a range
                    if (thisRef.indexOf('-') > 0) {
                        var rangeStart = parseInt(thisRef.split('-')[0]) || 0,
                            rangeEnd = parseInt(thisRef.split('-')[1]) || 0;
                    } else {
                        break;
                    }

                    // Check that they're both numbers before counting between them!
                    if (!isNaN(rangeStart) && !isNaN(rangeEnd)) {
                        
                        if (parseInt(rangeStart) > parseInt(rangeEnd)) { // Make sure we're counting the right way.
                            var rangeTemp = rangeStart;
                            rangeStart = rangeEnd;
                            rangeEnd = rangeTemp;
                        }
                        
                        for (var rangeCounter = rangeStart;
                             rangeCounter <= rangeEnd;
                             rangeCounter++ ) {
                            
                            containedReferences.unshift(String(rangeCounter));
                        }
                    }
                } else { // if (thisRef.indexOf('-') > 0)
                    containedReferences.push(thisRef);
                }
            }

            return (containedReferences.length > 0)? containedReferences : false;
        }
        
        /**
         * The _bind function establishes an event listener for a give object and initiates a
         * qTip2 tooltip on that object. There's a guard here in place to check if the event
         * occured from an actual tooltip, in which case we shouldn't remove the tooltip.
         * @method _bind
         * @static
         * @private
         * @return {Boolean} returns true if the bind process completed successfully, false
         *         if there were errors targeting the specified jQuery DOM object.
         */
        function _bind() {
            if (typeof $ === "undefined") {
                console.warn("No jQuery found!");
                return false;
            }
            
            var doc = $(document),
                ua = navigator.userAgent,
                eventType = ('ontouchstart' in document)? 'touchstart' : 'click';
            
            doc.bind(
                eventType,
                function(documentClickEvent) {
                    var thisNode = documentClickEvent.target;

                    if ($(thisNode).hasClass('ui-tooltip-content'))
                        return true;

                    while (thisNode = thisNode.parentNode) {
                        if ($(thisNode).hasClass('ui-tooltip-content')) {
                            return true;
                        }
                    }
                    com.ward6.EDetailerPage.References.hideAll();
                }
            );
        };
        
        /**
         * The addReference method is used to associate a tooltip with an individual jQuery DOM
         * object. Reference objects must be submitted in ReferenceObj format (see class profile
         * by clicking ReferenceObj).
         * @method addReference
         * @static
         * @param {ReferenceObj} referenceObj An object which maps a the contents of a &lt;sup&gt;
         *        tag's contents with a string of HTML with which to fill the tooltip.
         */
        ReferencesAPI.addReference = function(referenceObj) {
            var trigger = referenceObj.trigger,
                desc = referenceObj.description,
                foundTrigger = false,
                eventTrigger = ('ontouchstart' in document)? 'touchstart' : 'click';
            
            // Make sure all the information exists before proceeding.
            if (!trigger||!desc) {
                return false;
            }
            
            // Stop the event bubbling.
            trigger.bind(EDetailerAPI.UIEvents.UP, function(clickEvent) { return false; });
            
            if (typeof(trigger) === "object" && (typeof(trigger.length) === "number")) {
                var refPos = { // Default alignment settings.
                    my : { posX : "center", posY : "bottom" },
                    at : { posX : "center", posY : "top" }
                };
                
                // Find the location of the 
                var subPos = trigger.offset(),
                    forceLeft = trigger.hasClass("forceTipLeft"),
                    forceBottom = trigger.hasClass("forceTipBottom"),
                    forceTop = trigger.hasClass("forceTipTop"),
                    forceRight = trigger.hasClass("forceTipRight"),
                    forceWide = trigger.hasClass("forceTipWide");

                // Configure the X-Axis.
                if (subPos.left < 200) {
                    refPos.my.posX = "left";
                } else if (subPos.left > 824) {
                    refPos.my.posX = "right";
                }

                // Configure the Y-Axis.
                if (subPos.top < 200) {
                    refPos.my.posY = "top";
                    refPos.at.posY = "bottom";
                } else if (subPos.top > 568) {
                    refPos.my.posY = "bottom";
                    refPos.at.posY = "top";
                }

                if (forceLeft) {
                    refPos.my.posX = "right";
                    refPos.at.posX = "center";
                }

                if (forceBottom) {
                    refPos.my.posY = "top";
                    refPos.at.posY = "bottom";
                }

                if (forceTop) {
                    refPos.my.posY = "bottom";
                    refPos.at.posY = "top";
                }

                if (forceRight) {
                    refPos.my.posX = "left";
                    refPos.at.posX = "center";
                }

                trigger.qtip({
                    content : desc,
                    style: {
                        classes: "ui-tooltip-dark"
                    },                    
                    position: {
                        at: refPos.at.posY + " " + refPos.at.posX,
                        my: refPos.my.posY + " " + refPos.my.posX
                    },
                    show: {
                        event: eventTrigger,
                        effect: function() { $(this).fadeIn(150); }
                    },
                    hide: {
                        event: "unfocus",
                        effect: function() { $(this).fadeOut(150); }
                    }
                });
                
                trigger.addClass('clickable');
                
                foundTrigger = true;
                _referenceList.push(trigger);
                return foundTrigger;
            } else if (typeof(trigger) === "string") {
                // We need to find the <sup> tag to which this belongs.
                if (_supTags === undefined) {
                    _supTags = $('sup:not(.noTooltip)');
                }

                if (_supTags.length) {
                    _supTags.each(
                        function (supIndex, supElement) {
                            var supElement = $(supElement),
                                refList = _referenceList,
                                tipNumber = _referenceList.length;
                            if (supElement.html() === trigger) {
                                // Format the tooltip contents.
                                var hintContents = desc;
                                
                                // Determine a suitable origin and alignment...
                                
                                var refPos = { // Default alignment settings.
                                    at : { posX : "center", posY : "top" },
                                    my : { posX : "center", posY : "bottom" }
                                }; 
                                
                                // Find the location of the 
                                var subPos = supElement.offset();
                                if (subPos.left >= 600) {
                                    refPos.my.posX = "right";
                                } else if (subPos.left <= 180) {
                                    refPos.my.posX = "left";
                                }
                                if (subPos.top <= 300) {
                                    refPos.my.posY  = "top";
                                    refPos.at.posY  = "bottom";
                                }
                                
                                supElement.qtip({
                                    content: hintContents,
                                    prerender: true,
                                    position: {
                                        at: refPos.at.posY + " " + refPos.at.posX,
                                        my: refPos.my.posY + " " + refPos.my.posX
                                    },
                                    style: {
                                        classes: "ui-tooltip-dark",
                                    },
                                    show: {
                                        event: eventTrigger,
                                        effect: function() { $(this).fadeIn(150); }
                                    },
                                    hide: {
                                        event: "unfocus",
                                        effect: function() { $(this).fadeOut(150); }
                                    }
                                });
                                foundTrigger = true;
                                _referenceList.push(supElement);
                            }
                        } // end _supTags.each arguments
                    );
                    
                    if (!_pageBound) {
                        _bind();
                        _pageBound = true;
                    }
                }
                
            } else if (!trigger instanceof jQuery) {
                return false; // The type satisfies neither of the required types (String or jQuery).
            }
            
            return foundTrigger;
        };
        
        /**
         * Hides all the tooltips from view (applies to tooltips that are active or inactive).
         * @method hideAll
         */
        ReferencesAPI.hideAll = function(event) {
            var refNumber = _referenceList.length;
            
            while (refNumber--) {
                var thisRef = _referenceList[refNumber];
                thisRef.qtip('hide');
            }
        };
        
        /**
         * Creates a ReferenceObj object for use with addReference. All values are validated upon
         * calling this method.
         * @method createReferenceObj
         * @static
         * @param {jQuery or String} trigger a jQuery selected element which will activate the tooltip on
         *        click. Alternatively, the exact contents of a HTML &lt;sup&gt; tag may be supplied as a
         *        <code property="yui:type">String</code>. All  &lt;sup&gt; tags are parsed and if a tag exists
         *        with the specified contents it will become the trigger. <code property="yui:type">Strings</code>
         *        which are supplied and not matched are disregarded.
         * @param {String} description the HTML which will be injected into the tooltip.
         * @return {ReferenceObj} returns a new ReferenceObj with the attributes provided.
         */
        ReferencesAPI.createReferenceObj = function(trigger, description) {
            var newRef = {
                    trigger : trigger,
                    description : description
                };
            return newRef;
        };
        return ReferencesAPI;
    }());

    /**
     * This method displays a single profile on page load. It is only to be used
     * internally. If this is running outside of an iOS UIWebView component then
     * EDetailerPageAPI.activate is called 500ms after the window.load event.
     * @method _runOnce
     * @private
     */
    function _runOnce() {
        if (typeof($) === "undefined") {
            console.warn("PageLoad: jQuery not available!");
        }
        
        if (!EDetailerAPI.isApp)
            $(window).bind('load', function() { setTimeout(EDetailerAPI.activate, 500); });
    }

    _runOnce();

    return EDetailerAPI;
} ());

//To ensure backwards compatibility:
// Removed backwards compatibility for this eDetailer (uncomment to reinstate).
var EDetailerPage = com.ward6.EDetailerPage; 

/**
 * [ABSTRACT] A ReferenceObj object holds the necessary information to bind a 
 * &lt;sup&gt; tag to the information required for its tooltip. ReferenceObj
 * objects are used by the EDetailerPage.References.addReference method to add a
 * tooltip reference to the page. The EDetailerPage.References contains a
 * ReferenceObj factory (invoked by createReferenceObj) to create a new
 * ReferenceObj, otherwise a generic JavaScript object implementing the
 * properties below will suffice.
 * @class ReferenceObj
 */
 /**
 * The trigger specifies which DOM node will host the tooltip. This can be
 * provided as a jQuery object (referencing a single element). Alternatively,
 * this can be supplied as a <code property="yui:type">String</code> which is
 * identical to the contents of a HTML &lt;sup&gt; tag. If a &lt;sup&gt; tag is
 * found on the page with the same innerHTML as the
 * <code property="yui:type">String</code> supplied then it will become the
 * trigger for the tooltip. <code property="yui:type">Strings</code> which are
 * supplied and not matched are disregarded.
 * @property trigger
 * @type jQuery or String
 */
/**
 * The description property holds the HTML content that will be displayed in the
 * tooltip. The tooltip will automatically resize to the required dimensions.
 * The HTML provided should exclude the mandatory anchor link that will be
 * placed at the bottom of each tool tip.
 * @property description
 * @type String
 */
/**
 * A URL to the original document which this tooltip references. This link will
 * be generated automatically and placed at the bottom of the tooltip. Please
 * provide a full HTTP address.
 * @property targetLink
 * @type String
 */
/**
 * The HTML title attribute of the anchor that will be created within the
 * tooltip (based on the targetLink property).
 * @property targetLinkTitle
 * @type String
 */